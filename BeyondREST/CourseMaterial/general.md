# General

## Why HTTP-based RESTful Web APIs

* Broad support on nearly every platform by nearly every vendor
  * C# only recently got native gRPC implementation
  * SignalR is an open protocol, but primarily driven by Microsoft
* Robust standard
* Lots of learning material and support
* JSON payload is human readable, good for troubleshooting and learning
  * Protobuf cannot be read by humans easily
* Contract with *Swagger* aka *Open API*
  * Can be compared with *.proto* files in gRPC
  * Weak spot of SignalR
* Code generation with *Swagger* aka *Open API*
  * Can be compared with gRPC Compiler for C#
* Can be used directly from browser without reverse proxy
  * gRPC needs [gRPC-Web](https://learn.microsoft.com/en-us/aspnet/core/grpc/browser) for that
* Loose coupling (principally, any HTTP is valid)
  * gRPC has strict message specification
* Load balancing is simple because of request-response
  * Harder for gRPC and SignalR because standing TCP connection

## Why *not* HTTP-based RESTful Web APIs

* Large payload (JSON)
  * gRPC is faster because of binary serialization with *Protocol Buffers*
* Some domains do not map to resources
  * gRPC and SignalR publish services, not objects
* Code generated by Swagger tooling is sometimes questionable
  * Code generated by gRPC tooling is better
* Bi-directional communication only via [Webhooks](https://en.wikipedia.org/wiki/Webhook)
  * gRPC supports bi-directional communication
* Does not support streaming
  * [gRPC](https://docs.microsoft.com/en-us/aspnet/core/grpc/client#server-streaming-call) and [SignalR](https://docs.microsoft.com/en-us/aspnet/core/signalr/streaming) support bi-directional streaming
* Cancelling requests is tricky
  * gRPC supports [deadlines](https://grpc.io/blog/deadlines/)
* Only 1:1 communication, no broadcasting to multiple receivers (same is true for gRPC)
  * *SignalR* can broadcast to receiver groups
  * Message-based communication supports topics-and-subscriptions with multiple subscribers
* Communication partner must be online (same is true for gRPC and SignalR)
  * Messagebroker-based communication can buffer messages until receivers come back online
* No load-leveling (same is true for gRPC and SignalR)
* Client needs query capabilities (e.g. filtering, sorting, paging)
  * Add GraphQL/OData to support such scenarios
