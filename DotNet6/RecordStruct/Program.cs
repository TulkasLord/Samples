using System;
using System.Text;
using System.Text.Json.Serialization;

// =======================================================================================
//  Remember Records?
//
var p = new Person("Foo", "Bar", 42);
// The following line does not work because records are immutable
// p.LastName = "Baz";
Console.WriteLine(p.FirstName);

var b = new Product("Bike", "Mountainbike", 499m);
Console.WriteLine(b.Name);

// =======================================================================================
//  New: Record Structs
//
var v1 = new Vector2d(1d, 2d);
v1.X = 3d; // This works because get and set are generated by default
Console.WriteLine(v1.X);
Console.WriteLine(v1); // record structs implement ToString

var v2 = v1 with { X = 4d }; // We can use the with keyword
Console.WriteLine(v2.X);

// Note: At the time of writing, stackallow can be compiled on sharplab.io, but cannot be executed.
//       If you want to run this code on sharplab.io, comment the following statement.
Span<Vector2d> vectors = stackalloc Vector2d[]
{
    new Vector2d(1d, 2d),
    new Vector2d(3d, 4d),
};

var p1 = new Point(1d, 2d);
// p1.X = 3d; // This does not work because readonly records are immutable
Console.WriteLine(p1);

// Note: At the time of writing, deconstruct can be compiled on sharplab.io, but cannot be executed.
//       If you want to run this code on sharplab.io, comment the following statement.
var (x, y) = p1; // Deconstruction works similar to record classes.

var p2 = p1 with { X = 4d }; // We can use the with keyword

var o = new TypeA("FooBar", 42);
Console.WriteLine(o); // Prints "FooBar" because of sealed override

// =======================================================================================
//  Records?
//
// Usual syntax, results in record classes (=reference types)
record Person(string FirstName, string LastName, int Age);

// New syntax "record class"
record class Product(string Category, string Name, decimal Price);

// =======================================================================================
//  New struct record (=value type)
//
record struct Vector2d(double X, double Y)
{
    public static Vector2d operator +(Vector2d first, Vector2d second) =>
        new(first.X + second.X, first.Y + second.Y);
}

// Readonly leads to an immutable struct
// Note that you can use the property: syntax to apply attributes
// or you can apply attributes to manually declared properties.
readonly record struct Point(double X, [property: JsonPropertyName("y")] double Y)
{
    // It is possible to manually declare property.
    [JsonPropertyName("x")]
    public double X { get; init; } = X;

    // Although PrintMembers is private, we can add a custom implementation.
    // C# considers the members as "matching" if signature matches.
    private bool PrintMembers(StringBuilder sb)
    {
        sb.Append($"X/Y = {X}/{Y}");
        return true;
    }
}

record struct Vector3d(double X, double Y, double Z)
{
    // We can turn properties into fields
    // (works for record classes, too)
    public double X = X;
    public double Y = Y;
    public double Z = Z;
}

public abstract record BaseRecord(string Name)
{
    // The following line has not been possible before as
    // BaseRecord is not sealed. Now, it is allowed.
    public sealed override string ToString() => Name;
}

public sealed record TypeA(string Name, int Parameter) : BaseRecord(Name);
public sealed record TypeB(string Name, double Parameter) : BaseRecord(Name);
