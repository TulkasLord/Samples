using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
using System.Windows;
using SkiaSharp;

/// <summary>
/// Record to deserialize a spritesheet JSON.
/// </summary>
/// <remarks>
/// JSON is generated by https://www.codeandweb.com/free-sprite-sheet-packer.
/// </remarks>
public record Frame(
    string Filename,
    [property: JsonPropertyName("frame")] SKRect FrameCoordinates,
    SKRect SpriteSourceSize,
    SKSize SourceSize
);

/// <summary>
/// Represents a spritesheet consisting of image and data structure describing the frames.
/// </summary>
/// <remarks>
/// A spritesheet is a large, single image that consists of multiple smaller images. This is useful for
/// reducing the number operations (reading from resources, HTTP requests) required to load the images.
public record Spritesheet(
    SKImage Image,
    Dictionary<string, Frame> Frames
);

/// <summary>
/// Class that offers methods to load spritesheets.
/// </summary>
public static class SpritesheetLoader
{
    /// <summary>
    /// Loads a spritesheet from resources.
    /// </summary>
    /// <param name="json">JSON (in UTF8) description of the frames in the spritesheet.</param>
    /// <param name="resourceName">The name of the resource.</param>
    /// <remarks>
    /// JSON is generated by https://www.codeandweb.com/free-sprite-sheet-packer.
    /// </remarks>
    public static Spritesheet Load(ReadOnlySpan<byte> json, string resourceName)
    {
        // Check parameters, must not be null or empty
        ArgumentNullException.ThrowIfNullOrEmpty(resourceName);

        // Get image from resources
        var resourceStream = Application.GetResourceStream(new Uri(resourceName, UriKind.Relative));

        // Create Skia image from stream
        var bitmap = SKBitmap.Decode(resourceStream.Stream);
        var image = SKImage.FromBitmap(bitmap);

        // Deserialize JSON describing the frames
        var sprites = JsonSerializer.Deserialize<SpriteFrames>(json, new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,

            // Note that TypeInfoResolver allows us to specify JSON options for types we don't own (SKSize).
            // It also allows us to add converters for all instances of a specific type (SKRect).
            // This is new in .NET 7. For details see https://devblogs.microsoft.com/dotnet/system-text-json-in-dotnet-7/#modifying-json-contracts.
            TypeInfoResolver = new DefaultJsonTypeInfoResolver
            {
                Modifiers =
                {
                    (JsonTypeInfo jsonTypeInfo) =>
                    {
                        // Add converter to all properties of type SKRect
                        void AddConverter<T>(JsonConverter<T> converter)
                        {
                            var properties = jsonTypeInfo.Properties.Where(p => p.PropertyType == typeof(T));
                            foreach(var p in properties)
                            {
                                p.CustomConverter = converter;
                            }
                        }

                        AddConverter(new SKRectJsonConverter());
                        AddConverter(new FrameDictJsonConverter());

                        // Add property names to properties of SKSize
                        if (jsonTypeInfo.Type == typeof(SKSize))
                        {
                            var property = jsonTypeInfo.Properties.First(p => p.Name == "width");
                            property.Name = "w";
                            property = jsonTypeInfo.Properties.First(p => p.Name == "height");
                            property.Name = "h";
                        }
                    }
                }
            }
        }) ?? throw new ApplicationException("Failed to deserialize frames");
        return new(image, sprites.Frames);
    }
}

// Note the use of a file-scoped types here (new in C# 11). For details see
// https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/file
// and https://slides.com/rainerstropek/csharp-11/fullscreen#/3.

file record SpriteFrames(
  Dictionary<string, Frame> Frames
);

file class FrameDictJsonConverter : JsonConverter<Dictionary<string, Frame>>
{
    public override Dictionary<string, Frame>? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        // Here we have to convert an array of Frame objects to a dictionary.
        // The filename is used as the key.
        // Example JSON:
        // [
        //  { "filename": "Arctic (10).png", ... (rest of the Frame) },
        //  { "filename": "Arctic (11).png", ... },
        //  { "filename": "Arctic (12).png", ... }
        // ]

        if (reader.TokenType != JsonTokenType.StartArray)
        {
            throw new JsonException($"Invalid start token {reader.TokenType}, expeted {JsonTokenType.StartArray}");
        }

        var frames = new Dictionary<string, Frame>();
        while (reader.Read() && reader.TokenType != JsonTokenType.EndArray)
        {
            // Deserialize single frame
            var frame = JsonSerializer.Deserialize<Frame>(ref reader, options)
                ?? throw new JsonException("Could not deserialize frame");
            frames.Add(frame.Filename, frame);
        }

        return frames;
    }

    public override void Write(Utf8JsonWriter writer, Dictionary<string, Frame> value, JsonSerializerOptions options)
        => throw new NotImplementedException();
}

file class SKRectJsonConverter : JsonConverter<SKRect>
{
    public override SKRect Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        // The spritesheet JSON frequently contains size and dimensions of frames.
        // Example JSON: { "x": 0, "y": 0, "w": 264, "h": 335 }
        // Internally, we use SkiaSharp's SKRect to represent these values. So we have to
        // convert the JSON to an SKRect.

        if (reader.TokenType != JsonTokenType.StartObject)
        {
            throw new JsonException($"Invalid start token {reader.TokenType}, expeted {JsonTokenType.StartObject}");
        }

        var currentProperty = string.Empty;
        float x = 0f, y = 0f, w = 0f, h = 0f;
        while (reader.Read() && reader.TokenType != JsonTokenType.EndObject)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.PropertyName:
                    currentProperty = reader.GetString();
                    break;
                case JsonTokenType.Number:
                    switch (currentProperty)
                    {
                        case "x": x = reader.GetSingle(); break;
                        case "y": y = reader.GetSingle(); break;
                        case "w": w = reader.GetSingle(); break;
                        case "h": h = reader.GetSingle(); break;
                        default: throw new JsonException($"Unexpected property {currentProperty}");
                    }
                    break;
                default:
                    throw new JsonException($"Unexpected token {reader.TokenType}");
            }
        }

        return new SKRect(x, y, x + w, y + h);
    }

    public override void Write(Utf8JsonWriter writer, SKRect value, JsonSerializerOptions options)
        => throw new NotImplementedException();
}
